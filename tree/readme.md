[TOC]

https://time.geekbang.org/column/article/67856

[TOC]
[TOC]

## 基础
1. 定义

节点的高度
: 节点到叶子节点的最长路径(边数)

节点的深度
: 根节点到这个节点所经历的边的个数

节点的层数
: 节点的深度 + 1

树的高度
: 根节点的高度

如下图所示:
![image](C33CBF30F4554C47AA09D0CE40A94ADC)

> 记忆窍门: 我们的生活中，“高度”这个概念，其实就是从下往上度量，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。

二叉树
: 每个节点之多只有两棵子树的树形结构叫做二叉树, 二叉树的子树有左右之分，其次序不能任意颠倒

满二叉树
: 除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。

完全二叉树
: 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。

eg: 图1，2，3分别表示二叉树，满二叉树，完全二叉树
![image](65C0FD28BE5746F0AC15FA5B532DFCA1)

完全二叉树和非完全二叉树的区别

![image](F82EFF366B9342F7A9C32B8F9210F881)

### 二叉树的存储
我们知道树和图基本都可以用链表和数组两种存储方式来存储，最常用的链式存储法适合所有的二叉树，每个节点都有三个字段，data,left_point,right_point
![image](071114E0BDD7483BA09DEC1169AEB786)

因为数组是一段连续的内存空间，因此只有完全二叉树才适合用数组来存储
![image](EA80F4D6586B40C383380C16C3B11EE2)

> 堆和堆排序其实就是一种完全二叉树，最常用的存储方式就是数组。


### 二叉树的遍历
如何将所有节点都遍历打印出来呢？经典的方法有三种，前序遍历、中序遍历和后序遍历。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。

前序遍历
: 对于树中的任意节点来说， 先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

中序遍历
: 对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

后续遍历
: 对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树， 最后打印这个节点本身。

> 记忆诀窍:前序，中序和后序是根据父节点打印的顺序来区分，先打印父节点是前序，最后打印父节点是后序，中间打印时中序。

实际上二叉树的前中后序遍历就是一个递归的过程，比如前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。

递归公式模板:
```

void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印root节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印root节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印root节点
}
```

时间复杂度: 遍历操作的时间复杂度跟节点的个数n成正比，二叉树遍历的时间复杂度是O(n)


## 二叉查找树
